/* REDUCE V 1.glsl
 *   by Lut99
 *
 * Created:
 *   25/05/2021, 21:58:25
 * Last edited:
 *   25/05/2021, 22:27:39
 * Auto updated?
 *   Yes
 *
 * Description:
 *   GLSL compute shader that takes the sample storage for a single block
 *   of pixels and reduces that (i.e., averages it) to a single block.
**/

#version 450
#extension GL_GOOGLE_include_directive: require



/* Define the workgroup size(s). */
layout (local_size_x = 32, local_size_y = 32, local_size_z = 32) in;



/* Define specialization constants. */
// The width of the target frame
layout (constant_id = 0) const int width = 0;

// The height of the target frame
layout (constant_id = 1) const int height = 0;

// The number of samples we take per pixel
layout (constant_id = 2) const int n_samples = 0;



/* Define the buffers. */
// The information for the current invocation
layout(std140, set = 0, binding = 0) uniform BlockInfo {
    // The number of pixels that we are offset w.r.t. the topleft of the image
    uint x;
    // The number of pixels that we are offset w.r.t. the topleft of the image
    uint y;
    // The width of this block
    uint w;
    // The height of this block
    uint h;
} block_info;

// The input of the shader, which is the temporary storage buffer of block_info.w * block_info.h * n_samples samples generated by the raytrace shader
layout(std430, set = 2, binding = 3) buffer SampleStorage {
    // The resulting color for this pixel
    uint pixels[];
} sample_storage;

// The output of the shader, which is the width * height frame buffer.
layout(std430, set = 2, binding = 4) buffer Frame {
    // The resulting color for this pixel
    uint pixels[];
} frame;



/* The entry point to the shader. */
void main() {		
    // Get the index we're supposed to render
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    // Only continue if this instance is within range of our frame
    if (x < width && y < height && z < n_samples) {
        /* TBD */
    }
}
